#!/bin/bash
THIS_NAME="$(basename "${0}")"

_usage(){
    cat <<EOF
${THIS_NAME}

Provide visual and information reporting on audio files.
Usage:
    ${THIS_NAME} [options] file1.wav [file2.wav ...]
    or
    ${THIS_NAME} [options] list_of_wave_filepaths_to_process.txt
    or
    ${THIS_NAME} [options] directory/

The input can be a list of files, a text document that contains a list of files
or a directory of audio files. If the input is a directory, then ${THIS_NAME}
will review all audio files immediately within that directory.

Options:
    By analyzing audio files, ${THIS_NAME} will provide the following outputs.
    - A csv of metadata from the ffmpeg astats filter, stream metadata, and
      bwfmetaedit (one csv for all file inputs)
    - A csv of astats metadata per audio frame  (one csv for each file input)
    - An xml of metadata from ffprobe, the astats filter, and bwfmetaedit (one
      xml for all file inputs)
    - A png graph that visualizes data from the astats and phasemeter filters
      (one png for each file input)

 -h        (Show this message)
 -v        (Provide verbose output)

 -c (y|n)  (Enable file summary csv output, default 'y')
 -f (y|n)  (Enable audio frame astats csv output, default 'y')
 -x (y|n)  (Enable xml output, default 'y')
 -g (y|n)  (Enable graph output, default 'y')

 -m MIN    (if MIN is set, then the graph output will be in one image for each set of specified
           minutes of the timeline, otherwise the output will be in one image)

 -o DIR    (Send output files to the specified directory. Default is a directory next to the input.)

 -X        (By default the file summary csv will contain a core set of
            metadata. The '-X' option adds more values.)

EOF
}

if [ "${#}" = 0 ] ; then
    _usage
    exit 0
fi

OPTIND=1
CSV_SUMMARY_OUTPUT="y"
CSV_FRAMES_OUTPUT="y"
XML_OUTPUT="y"
GRAPH_OUTPUT="y"
FULL_DATA="n"
SAMPLES_PER_ASTATS_CSV="65536"
while getopts "hvc:f:x:g:o:Xm:" opt ; do
    case "${opt}" in
        h) _usage ; exit ;;
        v) VERBOSE=true ;;
        c) CSV_SUMMARY_OUTPUT="${OPTARG}" ;;
        f) CSV_FRAMES_OUTPUT="${OPTARG}" ;;
        x) XML_OUTPUT="${OPTARG}" ;;
        g) GRAPH_OUTPUT="${OPTARG}" ;;
        o) SET_OUTPUT_DIR="${OPTARG}" ;;
        X) FULL_DATA="y" ;;
        m) GRAPH_MINUTES_SET="${OPTARG}" ;;
        :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
        *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
    esac
done
shift "$((OPTIND-1))"

if [[ "$VERBOSE" == "true" ]] ; then
    :
else
    FFMPEG_VERBOSE=(-v 0)
fi

_add_column(){
    IF_FULL="n"
    unset RELABEL AS_PERCENT ROUND
    OPTIND=1
    while getopts "fr:PH" opt ; do
        case "${opt}" in
            f) IF_FULL="y" ;;
            r) RELABEL="${OPTARG}" ;;
            P) AS_PERCENT="Y" ;;
            H) ROUND="Y" ;;
            :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
            *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
        esac
    done
    shift "$((OPTIND-1))"
    REPORT_SOURCE="${1}"
    SECTION="${2}"
    KEY="${3}"
    VALUE="${4}"
    if [[ "${IF_FULL}" = "n" || ( "${FULL_DATA}" = "y" && "${IF_FULL}" = "y" ) ]] ; then
        if [[ "${FILE_NUMBER}" = "0" ]] ; then
            if [[ -n "${RELABEL}" ]] ; then
                CSV_HEADER+="${RELABEL},"
            elif [[ "${REPORT_SOURCE}" = "ffprobe" ]] ; then
                CSV_HEADER+="${SECTION}.${KEY},"
            elif [[ "${REPORT_SOURCE}" = "astats" ]] ; then
                if [[ "${SECTION:0:5}" = "lavfi" ]] ; then
                    CSV_HEADER+="${KEY// /_},"
                else
                    CSV_HEADER+="${KEY// /_}_${SECTION},"
                fi
            elif [[ "${REPORT_SOURCE}" = "bwfmetaedit" ]] ; then
                 CSV_HEADER+="${KEY##*/} (BWFME ${SECTION}),"
            elif [[ "${REPORT_SOURCE}" = "local" ]] ; then
                CSV_HEADER+="$(basename "${KEY}"),"
            fi
        fi
        if [[ "${REPORT_SOURCE}" = "ffprobe" ]] ; then
           CSV_VALUE="$(_flat_ffprobe_parse "${FFPROBE_REPORT}" "${SECTION}.${KEY}")"
        elif [[ "${REPORT_SOURCE}" = "astats" ]] ; then
            if [[ "${SECTION}" = "lavfi.aphasemeter.phase" ]] ; then
                CSV_VALUE="$(grep "${SECTION}=" "${FILTER_REPORT}" | cut -d "=" -f2 | awk '{s+=$1}END{print s/NR}')"
            else
                CSV_VALUE="$(_astats_parse "${FILTER_REPORT}" "${SECTION}" "${KEY}" "${VALUE}")"
            fi
        elif [[ "${REPORT_SOURCE}" = "bwfmetaedit" ]] ; then
            if [[ "${KEY}" == *"/"* ]]; then
                PARSE_FULL_XML="Y"
            else
                PARSE_FULL_XML="N"
            fi
            if [[ "${SECTION}" = "Core" || "${PARSE_FULL_XML}" = "Y" ]] ; then
                CSV_VALUE="$(_xml_parse "${KEY}" "${BWFMETAEDIT_XML}")"
            elif [[ "${SECTION}" = "Tech" ]] ; then
                CSV_VALUE="$(_csv_parse "${KEY}" "${BWFMETAEDIT_TECH}")"
            fi
        elif [[ "${REPORT_SOURCE}" = "local" ]] ; then
            CSV_VALUE="${VALUE}"
        else
            _report -w "Unexpected error in _add_column, REPORT_SOURCE=(${REPORT_SOURCE}), SECTION=(${SECTION}), KEY=(${KEY})"
            CSV_VALUE=""
        fi
        if [[ "${AS_PERCENT}" == "Y" && -n "${CSV_VALUE}" ]] ; then
            CSV_VALUE="$(echo "${CSV_VALUE}" | awk '{printf "%.2f%%", $1 * 100}')"
        elif [[ "${ROUND}" == "Y" && -n "${CSV_VALUE}" ]] ; then
            CSV_VALUE="$(echo "${CSV_VALUE}" | awk '{printf "%.2f", $1}')"
        fi
        CSV_VALUE="$(echo "${CSV_VALUE}" | sed 's|"|""|g')"
        if [[ "$(echo "${CSV_VALUE}" | grep -c '$')" != 1 || "${CSV_VALUE}" == *","* ]] ; then
            CSV_VALUE="\"${CSV_VALUE}\""
        fi
        CSV_ROW+="${CSV_VALUE},"
    fi
    if [[ "$KEY" == "File/Core/IMED" ]] ; then
        echo "${CSV_VALUE}|${FILENAME}" >> "${DUP_CHECK_TMP}"
    fi
}

_check_dependencies(){
    while [ "${*}" != "" ] ; do
        DEPENDENCY="${1}"
        if [ ! $(which "${DEPENDENCY}") ] ; then
            _report -wt "This script requires ${DEPENDENCY} to run but it is not installed"
            DEPS_OK=NO
        fi
        shift
    done
    if [[ "${DEPS_OK}" = "NO" ]]; then
        _report -wt "Unmet dependencies"
        _report -wt "Stopping!"
        exit 1
    else
        return 0
    fi
}

_find_a_font(){
    if [[ -f "/Library/Fonts/Andale Mono.ttf" ]] ; then
        FONT_FILE="/Library/Fonts/Andale Mono.ttf"
    elif [[ -f "/System/Library/Fonts/Supplemental/Andale Mono.ttf" ]] ; then
        FONT_FILE="/System/Library/Fonts/Supplemental/Andale Mono.ttf"
    elif [[ -f "/System/Library/Fonts/Monaco.dfont" ]] ; then
        FONT_FILE="/System/Library/Fonts/Monaco.dfont"
    elif [[ -f "/Library/Fonts/Microsoft/Lucida Console.ttf" ]] ; then
        FONT_FILE="/Library/Fonts/Microsoft/Lucida\Console.ttf"
    elif [[ -f "/Library/Fonts/LetterGothicStd.otf" ]] ; then
        FONT_FILE="/Library/Fonts/LetterGothicStd.otf"
    else
        _report -wt "astatsaudit can't find a preferred font to use."
    fi
}

_finish_xml(){
    INVENTORY_XML="${1}"
    _report -d "Finalizing xml output at ${INVENTORY_XML}"
    "${XMLSTARLET_PATH}" select \
        -N "rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#" \
        -N "asa=https://github.com/amiaopensource/astatsaudit" \
        -N "ffprobe=http://www.ffmpeg.org/schema/ffprobe" \
        -N "astats=https://ffmpeg.org/ffmpeg-filters.html#astats" \
        -N "bwfme=https://mediaarea.net/BWFMetaEdit" \
        -t \
            --elem "rdf:RDF" \
            --match "//f" \
            --elem "rdf:Description" \
                --attr "rdf:about" -v "." -b \
            --elem "asa:stats" \
                --elem "asa:dateTime" -v "date:date-time()" -b \
            -b \
            --elem "ffprobe:report" \
                  --attr "settings" -o "$(echo ${FFPROBE_CMD[@]})" -b \
                  --copy-of "document(@ff)/*" -b \
            --elem "astats:report" --copy-of "document(@astats)/astats/text()" -b \
            --elem "bwfme:fullReport" \
                  --copy-of "document(@bwf)/*" \
        "${INVENTORY_XML}" | "${XMLSTARLET_PATH}" fo
}

_flat_ffprobe_parse(){
    FFPROBE_DOC="${1}"
    KEY="${2}"
    VALUE="$(grep "^${KEY}=" "${FFPROBE_DOC}" | cut -d "=" -f2- | sed -e 's/^"//' -e 's/"$//')"
    VALUE_LINE_COUNT="$(echo -n "${VALUE}" | grep -c '^')"
    if [[ "${VALUE_LINE_COUNT}" -gt 1 ]] ; then
        _report -w "The parsed value for '${KEY}' is in ${VALUE_LINE_COUNT} lines, which may be unintended"
    fi
    echo -n "${VALUE}"
}

_astats_parse(){
    ASTATS_DOC="${1}"
    SECTION="${2}"
    KEY="${3}"
    FILTER_PREFIX="${4}"
    if [[ -z "${FILTER_PREFIX}" ]] ; then
        FILTER_PREFIX="Parsed_astats_0"
    fi
    if [[ "${SECTION}" == "Overall" ]] ; then
        VALUE="$(grep "${FILTER_PREFIX}" "${ASTATS_DOC}" | sed '1,/Overall$/d' | grep "] ${KEY}:" | cut -d : -f2- | sed 's/ //g')"
    elif [[ "${SECTION:0:5}" == "lavfi" ]] ; then
        grep "${SECTION}" "${ASTATS_DOC}" | cut -d "=" -f2- | head -n 1
    else
        VALUE="$(grep "${FILTER_PREFIX}" "${ASTATS_DOC}" | sed -n "s/Overall$/Channel: X/g;/Channel: ${SECTION}/,/Channel/p" | grep "] ${KEY}:" | cut -d : -f2- | sed 's/ //g')"
    fi
    VALUE_LINE_COUNT="$(echo -n "${VALUE}" | grep -c '^')"
    if [[ "${VALUE_LINE_COUNT}" -gt 1 ]] ; then
        _report -w "The parsed value for '${KEY}' is in ${VALUE_LINE_COUNT} lines, which may be unintended"
    fi
    echo -n "${VALUE}"
}

_csv_parse(){
    COL="${1}"
    CSV="${2}"
    COL_INDEX="$(echo "${CSV}" | sed -n $'1s/,/\\\n/gp' | grep -nx "${COL}" | cut -d: -f1)"
    if [[ -n "${COL_INDEX}" ]] ; then
        ROW_VALUE="$(echo "${CSV}" | tail -n +2 | cut -d , -f "${COL_INDEX}")"
        echo -n "${ROW_VALUE}"
    else
        _report -w "A column header ($COL) was expected by not found."
    fi
}

_xml_parse(){
    PATH="${1}"
    XML="${2}"
    echo "${XML}" | "${XMLSTARLET_PATH}" sel -t -m "/conformance_point_document" -v "${PATH}" -n
}

_get_iso8601(){
    date +%FT%T
}

_get_iso8601_c(){
    date +%Y%m%d-%H%M%S
}

_maketemp(){
    mktemp -q -t "$(basename "${0}").XXXXXX"
    if [ "${?}" -ne 0 ]; then
        echo "${0}: Can't create temp file, exiting..."
        exit 1
    fi
}

_report(){
    local RED="$(tput setaf 1)"    # Red      - For Warnings
    local GREEN="$(tput setaf 2)"  # Green    - For Declarations
    local BLUE="$(tput setaf 4)"   # Blue     - For Questions
    local MAGENTA="$(tput setaf 5)" # Magenta - For Verbose Statements
    local NC="$(tput sgr0)"        # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ECHOOPT=""
    local VERBOSE_CHECK=false
    OPTIND=1
    while getopts "vqdwstn" opt ; do
        case "${opt}" in
            v) VERBOSE_CHECK=true ;
               COLOR="${MAGENTA}" ;
               STARTMESSAGE+="#" ;; # only output the message if DV_VERBOSE=true
            q) COLOR="${BLUE}" ;;                        # question mode, use color blue
            d) COLOR="${GREEN}" ;;                       # declaration mode, use color green
            w) COLOR="${RED}" ;;                         # warning mode, use color red
            s) STARTMESSAGE+=([${SCRIPTNAME}] ) ;;       # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601) '- ' ) ;;  # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                           # to avoid line breaks after echo
        esac
    done
    shift "$((OPTIND-1))"
    MESSAGE="${1}"
    if ! "${VERBOSE_CHECK}" ; then
        >&2 echo ${ECHOOPT} "${COLOR}${STARTMESSAGE[@]}${MESSAGE}${NC}"
    fi
}

_ss_to_hhmmss(){
    # if milliseconds are used it will round down to nearest second for instance 60.9, will return 1:00
    OPTIND=1
    NO_SLASH="N"
    while getopts "c" opt ; do
        case "${opt}" in
            c) NO_SLASH="Y" ;;
        esac
    done
    shift "$((OPTIND-1))"
    if [[ "${1}" == "n/a" ]] ; then
        echo "${1}"
    else
        INT="${1%.*}"
        [[ -z "$INT" ]] && INT="0"
        DEC="$(echo "${1#*.}" | head -c 3)"
        if [[ "${NO_SLASH}" == "Y" ]] ; then
            printf "%02d:%02d:%02d.${DEC}\n" $(($INT/3600)) $(($INT%3600/60)) $(($INT%60))
        else
            printf "%02d\:%02d\:%02d.${DEC}\n" $(($INT/3600)) $(($INT%3600/60)) $(($INT%60))
        fi
    fi
}

_get_metadata(){
    FILENAME="${1}"
    BASENAME=$(basename "${FILENAME}")
    FILTER_REPORT="$(_maketemp)"
    FILTER_REPORT_XMLD="${2}"
    FFPROBE_REPORT="$(_maketemp)"
    if [[ "${XML_OUTPUT}" = "y" || "${CSV_SUMMARY_OUTPUT}" = "y" ]] ; then
        ffmpeg -nostdin -i "${FILENAME}" -vn -filter_complex "astats,asetnsamples=n=${SAMPLES_PER_ASTATS_CSV}:p=0,aphasemeter=video=0,ametadata=mode=print:key=lavfi.aphasemeter.phase,channelsplit,axcorrelate,astats" -f null - 2>&1 |  tr "\r" "\n" > "${FILTER_REPORT}"
        {
            echo "<astats>"
            grep "Parsed_astats" "${FILTER_REPORT}" | cut -d "]" -f2- | sed 's/^ //g'
            echo "</astats>"
        } > "${FILTER_REPORT_XMLD}"
    fi
    ffprobe -i "${FILENAME}" -show_format -show_streams -of flat 2> /dev/null > "${FFPROBE_REPORT}"
    if [[ "${CSV_SUMMARY_OUTPUT}" = "y" ]] ; then
        BWFMETAEDIT_REPORT=$(bwfmetaedit "$FILENAME" 2>&1 | awk '{printf "%s+",$0} END {print ""}')
        BWFMETAEDIT_TECH="$(bwfmetaedit --out-tech "$FILENAME")"
        BWFMETAEDIT_XML="$(bwfmetaedit --out-xml "${FILENAME}")"
    fi
}

_get_csv_row(){
    # this function expects to process the following variables:
    # FILTER_REPORT, FFPROBE_REPORT, BWFMETAEDIT_REPORT
    unset CSV_ROW

    _get_astats_2channel_offset(){
        KEY="${1}"
        VAL_1="$(_astats_parse "${FILTER_REPORT}" "1" "${KEY}")"
        VAL_2="$(_astats_parse "${FILTER_REPORT}" "2" "${KEY}")"
        if [[ -n "${VAL_1}" && -n "${VAL_2}" ]] ; then
            echo "${VAL_1} - ${VAL_2}" | bc
        fi
    }

    #local math
    if [[ "${CHANNEL_COUNT}" -gt 1 ]] ; then 
        RMS_level_ch_offset="$(_get_astats_2channel_offset "RMS level dB")"
        dynamic_range_ch_offset="$(_get_astats_2channel_offset "Dynamic range")"
        noise_floor_db_ch_offset="$(_get_astats_2channel_offset "Noise floor dB")"
        noise_floor_count_ch_offset="$(_get_astats_2channel_offset "Noise floor count")"
        NOISE_FLOOR_1_DURATION="$(echo "scale=3; ${SAMPLES_PER_ASTATS_CSV} * $(_astats_parse "${FILTER_REPORT}" "1" "Noise floor count")/ ${SAMPLE_RATE}" | bc)"
        NOISE_FLOOR_2_DURATION="$(echo "scale=3; ${SAMPLES_PER_ASTATS_CSV} * $(_astats_parse "${FILTER_REPORT}" "2" "Noise floor count")/ ${SAMPLE_RATE}" | bc)"
        noise_floor_duration_ch_offset="$(echo "scale=3; ${NOISE_FLOOR_1_DURATION} - ${NOISE_FLOOR_2_DURATION}" | bc)"
    else
        RMS_level_ch_offset="n/a"
        dynamic_range_ch_offset="n/a"
        noise_floor_db_ch_offset="n/a"
        noise_floor_count_ch_offset="n/a"
        NOISE_FLOOR_1_DURATION="n/a"
        NOISE_FLOOR_2_DURATION="n/a"
        noise_floor_duration_ch_offset="n/a"
    fi

    # the following _add_column functions use the following arguments
    # 1: 'astats to read from FILTER_REPORT
    #    'ffprobe' to read from FFPROBE_REPORT
    #    'bwfmetadata' to read from the --out-core or --out-tech request from BWF MetaEdit
    #    'local' to print local key/value pairs
    # 2: if $1=astats the $2 is the channel number or 'Overall'
    #    if $2=ffprobe then $2 is the section: format or streams
    #    if $1=bwfmetaedit then $2 is the section: Core or Tech
    #    if $1=local then $2 is unused
    # 3: the value or variable to parse from the referenced report
    # 4: if $1=astats then this is a filter for the astats occurrence (blank for primary, astats_6 for astats of the axcorrelation output (the 6th filter))
    #    if $1=local then this is the value for the $3 variable
    _add_column    local   ""      filename "${BASENAME}"
    _add_column -f ffprobe format  duration
    _add_column -f ffprobe streams stream.0.channels
    _add_column -f ffprobe streams stream.0.codec_name
    _add_column -f astats  1       "Bit depth"
    _add_column -f astats  2       "Bit depth"
    _add_column -f astats  1       "Crest factor"
    _add_column -f astats  2       "Crest factor"
    _add_column -P astats  1       "DC offset"
    _add_column -P astats  2       "DC offset"
    _add_column -f -P astats  Overall "DC offset"
    _add_column -H -r "Correlation (via phase)"        astats  lavfi.aphasemeter.phase   "Correlation"
    _add_column -f -r "Correlation (via axcorrelation)" astats  1       "DC offset"              "Parsed_astats_6"
    _add_column -f astats  1       "RMS difference"
    _add_column -f astats  2       "RMS difference"
    _add_column -f astats  Overall "RMS difference"
    _add_column -H astats  1       "RMS level dB"
    _add_column -H astats  2       "RMS level dB"
    _add_column -f -H astats  Overall "RMS level dB"
    _add_column -H local   ""      "RMS level channel offset" "${RMS_level_ch_offset}"
    _add_column -f astats  1       "RMS peak dB"
    _add_column -f astats  2       "RMS peak dB"
    _add_column -f astats  Overall "RMS peak dB"
    _add_column -f astats  1       "RMS trough dB"
    _add_column -f astats  2       "RMS trough dB"
    _add_column -f astats  Overall "RMS trough dB"
    _add_column -H astats  1       "Dynamic range"
    _add_column -H astats  2       "Dynamic range"
    _add_column -H local   ""      "Dynamic range offset" "${dynamic_range_ch_offset}" 2
    _add_column -H astats  1       "Peak level dB"
    _add_column -H astats  2       "Peak level dB"
    _add_column -f -H astats  Overall "Peak level dB"
    _add_column    astats  1       "Peak count"
    _add_column    astats  2       "Peak count"
    _add_column    astats  Overall "Peak count"
    _add_column    astats  1       "Flat factor"
    _add_column    astats  2       "Flat factor"
    _add_column -f astats  Overall "Flat factor"
    _add_column -f astats  1       "Max level"
    _add_column -f astats  2       "Max level"
    _add_column -f astats  Overall "Max level"
    _add_column -f astats  1       "Mean difference"
    _add_column -f astats  2       "Mean difference"
    _add_column -f astats  Overall "Mean difference"
    _add_column -f astats  1       "Min difference"
    _add_column -f astats  2       "Min difference"
    _add_column -f astats  Overall "Min difference"
    _add_column -f astats  1       "Min level"
    _add_column -f astats  2       "Min level"
    _add_column -f astats  Overall "Min level"
    _add_column -H astats  1       "Noise floor dB"
    _add_column -H astats  2       "Noise floor dB"
    _add_column -f -H astats  Overall "Noise floor dB"
    _add_column -H local   ""      "Noise floor dB offset" "${noise_floor_db_ch_offset}"
    _add_column -f astats  1       "Noise floor count"
    _add_column    local   ""      "Noise_floor_duration_1" "$(_ss_to_hhmmss -c "${NOISE_FLOOR_1_DURATION}")"
    _add_column -f astats  2       "Noise floor count"
    _add_column    local   ""      "Noise_floor_duration_2" "$(_ss_to_hhmmss -c "${NOISE_FLOOR_2_DURATION}")"
    _add_column -f astats  Overall "Noise floor count"
    _add_column -f local   ""      "Noise floor count offset" "${noise_floor_count_ch_offset}"
    _add_column    local   ""      "Noise floor duration offset" "$(_ss_to_hhmmss -c "${noise_floor_duration_ch_offset#-}")"
    _add_column    astats  1       "Max difference"
    _add_column    astats  2       "Max difference"
    _add_column -f astats  Overall "Max difference"
    _add_column -f astats  Overall "Number of samples"
    _add_column -f ffprobe streams stream.0.sample_rate
    _add_column -f astats  1       "Zero crossings"
    _add_column -f astats  2       "Zero crossings"
    _add_column -f astats  1       "Zero crossings rate"
    _add_column -f astats  2       "Zero crossings rate"
    _add_column -f local   ""      bwfmetaedit "${BWFMETAEDIT_REPORT}"
    _add_column    bwfmetaedit Tech File/Technical/FileName
    _add_column    bwfmetaedit Tech File/Technical/FileSize
    _add_column    bwfmetaedit Tech File/Technical/Format
    _add_column    bwfmetaedit Tech File/Technical/CodecID
    _add_column    bwfmetaedit Tech File/Technical/Channels
    _add_column    bwfmetaedit Tech File/Technical/SampleRate
    _add_column    bwfmetaedit Tech File/Technical/BitRate
    _add_column    bwfmetaedit Tech File/Technical/BitPerSample
    _add_column    astats  Overall "Bit depth"
    _add_column    bwfmetaedit Tech File/Technical/Duration
    _add_column    bwfmetaedit Tech UnsupportedChunks
    _add_column    bwfmetaedit Tech File/Technical/bext
    _add_column    bwfmetaedit Tech File/Technical/INFO
    _add_column    bwfmetaedit Tech File/Technical/Cue
    _add_column    bwfmetaedit Tech File/Technical/XMP
    _add_column    bwfmetaedit Tech File/Technical/aXML
    _add_column    bwfmetaedit Tech File/Technical/iXML
    _add_column    bwfmetaedit Tech File/Technical/MD5Stored
    _add_column    bwfmetaedit Tech MD5Generated
    _add_column    bwfmetaedit Tech Errors
    _add_column    bwfmetaedit Tech Warnings
    _add_column    bwfmetaedit Tech File/Technical/Information
    _add_column    bwfmetaedit Core File/Core/Description
    _add_column    bwfmetaedit Core File/Core/Originator
    _add_column    bwfmetaedit Core File/Core/OriginatorReference
    _add_column    bwfmetaedit Core File/Core/OriginationDate
    _add_column    bwfmetaedit Core File/Core/OriginationTime
    _add_column    bwfmetaedit Core File/Core/TimeReference_translated
    _add_column    bwfmetaedit Core File/Core/TimeReference
    _add_column    bwfmetaedit Core File/Core/BextVersion
    _add_column    bwfmetaedit Core File/Core/UMID
    _add_column    bwfmetaedit Core File/Core/LoudnessValue
    _add_column    bwfmetaedit Core File/Core/LoudnessRange
    _add_column    bwfmetaedit Core File/Core/MaxTruePeakLevel
    _add_column    bwfmetaedit Core File/Core/MaxMomentaryLoudness
    _add_column    bwfmetaedit Core File/Core/MaxShortTermLoudness
    _add_column    bwfmetaedit Core File/Core/CodingHistory
    _add_column    bwfmetaedit Core File/Core/IARL
    _add_column    bwfmetaedit Core File/Core/IART
    _add_column    bwfmetaedit Core File/Core/ICMS
    _add_column    bwfmetaedit Core File/Core/ICMT
    _add_column    bwfmetaedit Core File/Core/ICOP
    _add_column    bwfmetaedit Core File/Core/ICRD
    _add_column    bwfmetaedit Core File/Core/IENG
    _add_column    bwfmetaedit Core File/Core/IGNR
    _add_column    bwfmetaedit Core File/Core/IKEY
    _add_column    bwfmetaedit Core File/Core/IMED
    _add_column    bwfmetaedit Core File/Core/INAM
    _add_column    bwfmetaedit Core File/Core/IPRD
    _add_column    bwfmetaedit Core File/Core/ISBJ
    _add_column    bwfmetaedit Core File/Core/ISFT
    _add_column    bwfmetaedit Core File/Core/ISRC
    _add_column    bwfmetaedit Core File/Core/ISRF
    _add_column    bwfmetaedit Core File/Core/ITCH
}

_make_astats_csv_body(){
    FILENAME="${1}"
    ASTATS_CSV="${2}"
    ffprobe -v 0 -f lavfi -i "amovie=${FILENAME},astats=metadata=1:reset=1" -show_frames -of csv >> "${ASTATS_CSV}"
}

_make_astats_csv(){
    OPTIND=1
    unset OUTPUT_DIR
    while getopts "o:" opt ; do
        case "${opt}" in
            o) OUTPUT_DIR="${OPTARG}" ;;
            :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
            *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
        esac
    done
    shift "$((OPTIND-1))"

    FILENAME="$1"
    if [[ -z "${OUTPUT_DIR}" ]] ; then
        OUTPUT_DIR="$(dirname "${FILENAME}")"
    fi
    BASENAME="$(basename "${FILENAME}")"
    ASTATS_CSV="${OUTPUT_DIR}/${BASENAME}.astats.csv"
    DURATION="${2}"
    DURATION_LITTLE_LESS="$(echo "${DURATION}" - 0.1 | bc -l)"
    if [[ ! -f "${ASTATS_CSV}" ]] ; then
        _report -d "    Making astats csv for ${BASENAME}"
        ffprobe -f lavfi -i "amovie=${FILENAME}:sp=${DURATION_LITTLE_LESS},astats=metadata=1:reset=1" -show_frames -of csv=nk=0 2>/dev/null | tail -n 1 | sed 's/=[^,]*//g' > "${ASTATS_CSV}"
        _make_astats_csv_body "${FILENAME}" "${ASTATS_CSV}"
    else
        _report -d "    Astats csv for ${BASENAME} already exists, skipping."
    fi
}

_make_graph(){
    OPTIND=1
    unset OUTPUT_DIR
    while getopts "o:" opt ; do
        case "${opt}" in
            o) OUTPUT_DIR="${OPTARG}" ;;
            :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
            *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
        esac
    done
    shift "$((OPTIND-1))"

    FILENAME="${1}"
    if [[ -z "${OUTPUT_DIR}" ]] ; then
        OUTPUT_DIR="$(dirname "${FILENAME}")"
    fi
    BASENAME=$(basename "${FILENAME}")
    # image settings
    AUDIO_SAMPLE_RATE=48000
    HEADER_HEIGHT=24
    HEADER_HEIGHT_BIG=$(echo "${HEADER_HEIGHT} * 2" | bc)
    TIMELINE_FONTSIZE=16
    DRAWGRAPH_SETTINGS="bg=Black"
    BORDER_COLOR="LightGrey"
    HORIZONTAL_MARKINGS_240="drawgrid=thickness=1:color=${BORDER_COLOR}@0.2:height=ih/16,drawgrid=thickness=1:color=${BORDER_COLOR}@0.5:height=ih/4,drawgrid=thickness=1:color=${BORDER_COLOR}@0.8:height=ih/2"
    GRAPH_W=6000
    if [[ -n "${GRAPH_MINUTES_SET}" ]] ; then
        AUDIO_SAMPLE_RATE="${SAMPLE_RATE}"
        AUDIO_FRAME_SIZE="$(printf "%.0f" $(echo "scale=2;((${GRAPH_MINUTES_SET}*60*${SAMPLE_RATE})/${GRAPH_W})+0.5" | bc))"
    else
        AUDIO_SAMPLE_RATE=48000
    AUDIO_FRAME_SIZE="$(echo "((${DURATION}*${AUDIO_SAMPLE_RATE})/${GRAPH_W})+1" | bc)"
    fi
    # adding 0.5 in the above equation to ensure that the result is rounded to the nearest integer, rather than simply rounded down
    AUDIOFORMAT="aresample=${AUDIO_SAMPLE_RATE},aformat=sample_fmts=dbl,asetnsamples=n=${AUDIO_FRAME_SIZE}:p=0"
    VERTICAL_MARKINGS=$(echo "${GRAPH_W} / 150" | bc)
    GRAPH_H="576"
    PAD_W="240"

    _make_a_graph(){
        OPTIND=1
        unset GRAPH_START GRAPH_DURATION
        while getopts "s:d:" opt ; do
            case "${opt}" in
                s) GRAPH_START="${OPTARG}" ;;
                d) GRAPH_DURATION="${OPTARG}" ;;
                :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
                *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
            esac
        done
        INPUT_OPTS=(-nostdin)
        INPUT_OPTS+=(-y)
        INPUT_OPTS_ADDONS=("${1}")
        if [[ -n "${GRAPH_START}" ]] ; then
            INPUT_OPTS+=(-ss "${GRAPH_START}:00")
        fi
        if [[ -n "${GRAPH_DURATION}" ]] ; then
            INPUT_OPTS+=(-t "${GRAPH_DURATION}:00")
        fi
    unset TIMELINE
    COUNTER=0
    while [ "${COUNTER}" -lt "${VERTICAL_MARKINGS}" ]; do
        ((COUNTER++))
        if [[ -z "${GRAPH_START}" ]] ; then
            GRAPH_START="0"
        fi
        if [[ -n "${GRAPH_DURATION}" ]] ; then
            PLOT_DURATION="$(echo "${GRAPH_DURATION} * 60" | bc)"
            GRAPH_PART=" Graph #${SEGMENT_NUMBER} Starting at ${GRAPH_START}\:00"
        else
            PLOT_DURATION="${DURATION}"
        fi
        MARK="$(echo "scale=6; (${PLOT_DURATION} * ($COUNTER / $VERTICAL_MARKINGS)) + (${GRAPH_START} * 60)" | bc)"
        MARK_X="$(echo "scale=6; $GRAPH_W * ($COUNTER / $VERTICAL_MARKINGS)" | bc)"
        MARK_TIME="$(_ss_to_hhmmss "${MARK}")"
        TIMELINE+=",drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:text='${MARK_TIME}':x=${MARK_X}-text_w:y=(${HEADER_HEIGHT}-${TIMELINE_FONTSIZE})/2"
    done
    GRAPH_FILTER="asplit=5[j][k][l][m][n];
        `#timeline`
        color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT}${TIMELINE},split=9[top1][top2][top3][top4][top5][top6][top7][top8][top9];
        color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT_BIG},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=36:text='Audio QC Graph\:   Filename\: ${BASENAME},   Duration\: $(_ss_to_hhmmss "${DURATION}"),   Audio Frame Size Displayed\: ${AUDIO_FRAME_SIZE}  ${GRAPH_PART}'[Header];
        `#peak/rms left`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Channel 1 Level, -144 to 0 dBFS, Blue=peak, Yellow=RMS'[peakLH];
        `#peak/rms right`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Channel 2 Level, -144 to 0 dBFS, Purple=peak, Yellow=RMS'[peakRH];
        `#min/max`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Audio Min/Max Level -1...1. Blue=channel 1, Purple=channel 2.'[minmaxH];
        `#zero crossing rate`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Ratio of Zero Crossing Count to Sample Rate, 0 - 1. Blue=channel 1, Purple=channel 2.'[zeroH];
        `#phase`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Correlation, -1 to 1'[phaseH];
        `#dc offset`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='DC Offset, -0.01 to 0.01 dBFS offset in the mean displacement from 0'[dcoffH];
        `#axcorrelate`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Normalized Cross Correlation, 1=highly correlated, 0=not correlated, -1=out of phase.'[axcH];
        `#spectrum`color=c=${BORDER_COLOR}:s=${GRAPH_W}x${HEADER_HEIGHT},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=24:text='Audio frequency spectrum'[spectH];
        [j]${AUDIOFORMAT},astats=metadata=1:reset=1,asplit=4[astats1][astats2][astats3][astats4];
            [astats1]adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.astats.1.Peak_level:fg1=0xFFE6D8AD:
                m2=lavfi.astats.1.RMS_level:fg2=0xFF00FFFF:
                max=0:min=-144:
                slide=picture:
                mode=line:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[peakL1];
            [astats2]adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.astats.2.Peak_level:fg1=0xFFFF00FF:
                m2=lavfi.astats.2.RMS_level:fg2=0xFF00FFFF:
                max=0:min=-144:
                slide=picture:
                mode=line:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[peakR1];
            [astats3]adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.astats.1.Max_level:fg1=0xFFE6D8AD:
                m2=lavfi.astats.2.Max_level:fg2=0xFFFF00FF:
                m3=lavfi.astats.1.Min_level:fg3=0xFFE6D8AD:
                m4=lavfi.astats.2.Min_level:fg4=0xFFFF00FF:
                min=-1:max=1:
                slide=picture:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[minmax1];
            [astats4]adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.astats.1.Zero_crossings_rate:fg1=0xFFE6D8AD:
                m2=lavfi.astats.2.Zero_crossings_rate:fg2=0xFFFF00FF:
                min=0:max=1:
                slide=picture:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[zero1];
        [k]${AUDIOFORMAT},astats=metadata=1,adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.astats.1.DC_offset:fg1=0xFFE6D8AD:
                m2=lavfi.astats.2.DC_offset:fg2=0xFFFF00FF:
                min=-0.01:max=0.01:
                slide=picture:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[dcoff1];
        [l]${AUDIOFORMAT},asubcut=order=10:cutoff=25,asupercut=order=10:cutoff=20000,aphasemeter=video=0,
            adrawgraph=${DRAWGRAPH_SETTINGS}:
                m1=lavfi.aphasemeter.phase:fg1=if(gte(VAL\,0.9)\,0xFF00FF00\,if(gte(VAL\,0)\,0xFF00FFFF\,if(gte(VAL\,-0.5)\,0xFF0096FF\,0xFF0000FF))):
                max=1.01:min=-1:
                slide=picture:
                s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[phase1];
        [m]${AUDIOFORMAT},aformat=cl=stereo,channelsplit,axcorrelate=size=1024:algo=slow,astats=metadata=1:reset=1,${AUDIOFORMAT},
            adrawgraph=${DRAWGRAPH_SETTINGS}:m1=lavfi.astats.1.Max_level:fg1=0xFFE6D8AD:
            max=1.01:min=-1:slide=picture:mode=line:s=${GRAPH_W}x${GRAPH_H},${HORIZONTAL_MARKINGS_240}[axc1];
        [n]${AUDIOFORMAT},showspectrumpic=mode=separate:legend=0:s=${GRAPH_W}x${GRAPH_H}[spect1];
        [Header]
        [top1][peakLH][peakL1]
        [top2][peakRH][peakR1]
        [top3][minmaxH][minmax1]
        [top4][zeroH][zero1]
        [top5][phaseH][phase1]
        [top6][axcH][axc1]
        [top7][dcoffH][dcoff1]
        [top8][spectH][spect1]
        [top9]vstack=26,drawgrid=thickness=1:color=gray@0.5:width=iw/${VERTICAL_MARKINGS},drawgrid=thickness=1:color=${BORDER_COLOR}@0.2:width=(iw/${VERTICAL_MARKINGS})/10[graph];
        color=c=${BORDER_COLOR}:s=${PAD_W}x${HEADER_HEIGHT_BIG}[HeaderG];
        color=c=${BORDER_COLOR}:s=${PAD_W}x${HEADER_HEIGHT},split=17[top1G][top2G][top3G][top4G][top5G][top6G][top7G][top8G][top9G][peakLHG][peakRHG][minmaxHG][zeroHG][phaseHG][dcoffHG][spectHG][axcHG];
        `#empty_grat`color=c=${BORDER_COLOR}:s=${PAD_W}x${GRAPH_H}[spect1G];
        `#0-1_240p_grat`color=c=${BORDER_COLOR}:s=${PAD_W}x${GRAPH_H},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.52:x=w*0.7:text='0.5',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.77:x=w*0.7:text='0.25',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.27:x=w*0.7:text='0.75',drawgrid=thickness=1:color=black@0.2:height=ih/16,drawgrid=thickness=1:color=black@0.5:height=ih/4,drawgrid=thickness=1:color=black@0.8:height=ih/2[zero1G];
        `#-1-1_240p_grat`color=c=${BORDER_COLOR}:s=${PAD_W}x${GRAPH_H},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.52:x=w*0.7:text='0',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.77:x=w*0.7:text='-0.5',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.27:x=w*0.7:text='+0.5',drawgrid=thickness=1:color=black@0.2:height=ih/16,drawgrid=thickness=1:color=black@0.5:height=ih/4,drawgrid=thickness=1:color=black@0.8:height=ih/2,split=3[minmax1G][phase1G][axc1G];
        `#-0.01-0.01_240p_grat`color=c=${BORDER_COLOR}:s=${PAD_W}x${GRAPH_H},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.52:x=w*0.7:text='0',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.77:x=w*0.7:text='-0.005',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.27:x=w*0.7:text='+0.005',drawgrid=thickness=1:color=black@0.2:height=ih/16,drawgrid=thickness=1:color=black@0.5:height=ih/4,drawgrid=thickness=1:color=black@0.8:height=ih/2[dcoff1G];
        `#-144-0_240p_grat`color=c=${BORDER_COLOR}:s=${PAD_W}x${GRAPH_H},drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.52:x=w*0.7:text='-72',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.77:x=w*0.7:text='-108',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.27:x=w*0.7:text='-36',drawtext=fontfile=${FONT_FILE}:fontcolor=black:fontsize=${TIMELINE_FONTSIZE}:y=h*0.02:x=w*0.7:text='0',drawgrid=thickness=1:color=black@0.2:height=ih/16,drawgrid=thickness=1:color=black@0.5:height=ih/4,drawgrid=thickness=1:color=black@0.8:height=ih/2,split=2[peakL1G][peakR1G];
        [HeaderG]
        [top1G][peakLHG][peakL1G]
        [top2G][peakRHG][peakR1G]
        [top3G][minmaxHG][minmax1G]
        [top4G][zeroHG][zero1G]
        [top5G][phaseHG][phase1G]
        [top6G][axcHG][axc1G]
        [top7G][dcoffHG][dcoff1G]
        [top8G][spectHG][spect1G]
        [top9G]vstack=26[grat];
        [grat][graph]hstack=2[chart]"

        _report -d "    Generating a graph at ${OUTPUT_GRAPH} with ${INPUT_OPTS[*]}"
        ffmpeg "${FFMPEG_VERBOSE[@]}" "${INPUT_OPTS[@]}" -i "$FILENAME" -filter_complex "${GRAPH_FILTER}" \
            -map "[chart]" -vframes 1 "${OUTPUT_GRAPH}"
    }
    if [[ -n "${GRAPH_MINUTES_SET}" ]] ; then
        SEGMENT_NUMBER=1
        STARTING_MIN=0
        DURATION_MIN="$(printf "%.0f" "$(echo "(${DURATION} / 60) + 0.5" | bc)")"
        while [[ "${STARTING_MIN}" -lt "${DURATION_MIN}" ]] ; do
            OUTPUT_GRAPH="${OUTPUT_DIR}/${BASENAME}.astatsaudit.${SEGMENT_NUMBER}.png"
            _make_a_graph -s "${STARTING_MIN}" -d "${GRAPH_MINUTES_SET}"
            SEGMENT_NUMBER=$((SEGMENT_NUMBER+1))
            STARTING_MIN=$((STARTING_MIN+GRAPH_MINUTES_SET))
        done
    else
        OUTPUT_GRAPH="${OUTPUT_DIR}/${BASENAME}.astatsaudit.png"
        _make_a_graph "${SEGMENTING_RULES[@]}"
    fi
}

_process_file(){
    OPTIND=1
    unset OUTPUT_DIR
    while getopts "o:" opt ; do
        case "${opt}" in
            o) OUTPUT_DIR="${OPTARG}" ;;
            :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
            *) echo "bad option -${OPTARG}" ; _usage ; exit 1 ;;
        esac
    done
    shift "$((OPTIND-1))"

    FILENAME="$1"
    if [[ -z "${OUTPUT_DIR}" ]] ; then
        OUTPUT_DIR="$(dirname "${FILENAME}")"
    fi
    BASENAME="$(basename "${FILENAME}")"
    unset CSV_ROW
    FILTER_TMP_XMLD="$(_maketemp)"
    CHANNEL_COUNT="$(ffprobe -v 0 -i "${FILENAME}" -show_entries stream=channels -select_streams a:0 -of default=nk=1:nw=1)"
    _report -d "Processing: ${BASENAME}"
    if [[ "${CSV_SUMMARY_OUTPUT}" = "y" || "${XML_OUTPUT}" = "y" || "${GRAPH_OUTPUT}" = "y" ]] ; then
        _get_metadata "${FILENAME}" "${FILTER_TMP_XMLD}"
        SAMPLE_RATE=$(_flat_ffprobe_parse "${FFPROBE_REPORT}" streams.stream.[0-9].sample_rate)
    fi
    if [[ ! -d "${OUTPUT_DIR}" ]] ; then
        mkdir -p "${OUTPUT_DIR}"
    fi
    if [[ "${XML_OUTPUT}" = "y" ]] ; then
        # gather xml data
        FFMPEG_TMP="${FILES_XML_TMP}.ff.${FILE_NUMBER}.xml"
        BWFME_TMP="${FILES_XML_TMP}.bwf.${FILE_NUMBER}.xml"
        echo "<f ff=\"${FFMPEG_TMP}\" bwf=\"${BWFME_TMP}\" astats=\"${FILTER_TMP_XMLD}\">$(echo "${FILENAME}" | sed 's/.*\/\|.*\///g')</f>" >> "${FILES_XML_TMP}"
        FFPROBE_CMD=(ffprobe -v 0 "${FILENAME}" "${FFPROBE_SETTINGS[@]}")
        "${FFPROBE_CMD[@]}" > "${FFMPEG_TMP}"
        BWFME_CMD=(bwfmetaedit --out-core-xml="${BWFME_TMP}" "${FILENAME}")
        "${BWFME_CMD[@]}" 2>/dev/null
    fi
    if [[ "${CSV_SUMMARY_OUTPUT}" = "y" ]] ; then
        # express csv row (with header if on first row)
        _report -d "    Adding metadata to the file summary csv"
        _get_csv_row "${FILENAME}"
        if [[ "${FILE_NUMBER}" = "0" ]] ; then
            echo "${CSV_HEADER}" | sed 's/,$//' > "${OUTPUT_CSV}"
        fi
        echo "${CSV_ROW}" | sed 's/,$//' >> "${OUTPUT_CSV}"
    fi
    if [[ "${GRAPH_OUTPUT}" = "y" ]] ; then
        # variables to keep
        DURATION=$(_flat_ffprobe_parse "${FFPROBE_REPORT}" format.duration)
        SAMPLE_RATE=$(_flat_ffprobe_parse "${FFPROBE_REPORT}" streams.stream.[0-9].sample_rate)
        DURATION_TS=$(_flat_ffprobe_parse "${FFPROBE_REPORT}" stream.duration_ts)
        _make_graph -o "${OUTPUT_DIR}" "${FILENAME}"
    fi
    if [[ "${CSV_FRAMES_OUTPUT}" = "y" ]] ; then
        _make_astats_csv -o "${OUTPUT_DIR}" "${FILENAME}" "${DURATION}"
    fi
}

_check_dependencies bwfmetaedit ffmpeg ffprobe bc xmlstarlet
XMLSTARLET_PATH="$(which xmlstarlet)"
_find_a_font

FILE_NUMBER="0"
CSV_HEADER=""
CSV_ROW=""

INPUT="$1"
FFPROBE_SETTINGS=(-of xml=x=1:q=1 -noprivate -show_format -show_streams -show_chapters)
NOW="$(_get_iso8601_c)"
INPUT_EXT="${INPUT##*.}"

if [[ -f "${INPUT}" && "${INPUT_EXT}" != "txt" ]] ; then
    _report -d "${THIS_NAME} will process this list of files: ${@}"
    OUTPUT_CSV="astatsaudit_${NOW}.csv"
    while [[ "${@}" != "" ]] ; do
        INPUT="$1"
        FILES_XML_TMP="$(_maketemp)"
        DUP_CHECK_TMP="$(_maketemp)"
        if [[ -n "${SET_OUTPUT_DIR}" ]] ; then
            OUTPUT_XML="${SET_OUTPUT_DIR}/$(basename "${INPUT}").astatsaudit.xml"
        else
            OUTPUT_XML="${INPUT}.astatsaudit.xml"
        fi
        IS_AUDIO="$(ffprobe "${FFMPEG_VERBOSE[@]}" -v 0 "${INPUT}" -show_entries stream=codec_type -select_streams a:0 -of default=nk=1:nw=1)"
        if [[ "${IS_AUDIO}" = "audio" ]] ; then
            if [[ -n "${SET_OUTPUT_DIR}" ]] ; then
                _process_file -o "${SET_OUTPUT_DIR}" "${INPUT}"
            else
                _process_file "${INPUT}"
            fi
            if [[ "${XML_OUTPUT}" = "y" ]] ; then
                _finish_xml "${FILES_XML_TMP}" > "${OUTPUT_XML}"
            fi
            ((FILE_NUMBER++))
        else
            _report -d "Skipping: ${INPUT} (no audio stream found)"
        fi
        shift
    done
elif [[ -d "${INPUT}" || ( -f "${INPUT}" && "${INPUT_EXT}" == "txt" ) ]] ; then
    if [[ -n "${SET_OUTPUT_DIR}" ]] ; then
        OUTPUT_DIR="${SET_OUTPUT_DIR}"
    else
        OUTPUT_DIR="${INPUT}_astatauditfiles"
    fi
    _report -d "${THIS_NAME} will process audio files in ${INPUT} to ${OUTPUT_DIR}."
    if [[ -d "${OUTPUT_DIR}" && -z "${SET_OUTPUT_DIR}" ]] ; then
        _report -w "Error: ${OUTPUT_DIR} already exists."
        exit 1
    else
        mkdir -p "${OUTPUT_DIR}"
    fi
    FILES_XML_TMP="$(_maketemp)"
    DUP_CHECK_TMP="$(_maketemp)"
    OUTPUT_XML="${OUTPUT_DIR}/astatsaudit_${NOW}.xml"
    OUTPUT_CSV="${OUTPUT_DIR}/astatsaudit_${NOW}.csv"
    echo "<files>" > "${FILES_XML_TMP}"
    if [[ -d "${INPUT}" ]] ; then
        while read FILE ; do
            IS_AUDIO="$(ffprobe "${FFMPEG_VERBOSE[@]}" -v 0 "${FILE}" -show_entries stream=codec_type -select_streams a:0 -of default=nk=1:nw=1)"
            if [[ "${IS_AUDIO}" = "audio" ]] ; then
                _process_file -o "${OUTPUT_DIR}" "${FILE}"
                ((FILE_NUMBER++))
            else
                _report -d "Skipping: ${FILE} (no audio stream found)"
            fi
        done < <(find "${INPUT}" -maxdepth 1 -type f ! -name ".*")
    else
        while read FILE ; do
            IS_AUDIO="$(ffprobe "${FFMPEG_VERBOSE[@]}" -v 0 "${FILE}" -show_entries stream=codec_type -select_streams a:0 -of default=nk=1:nw=1)"
            if [[ "${IS_AUDIO}" = "audio" ]] ; then
                _process_file -o "${OUTPUT_DIR}" "${FILE}"
                ((FILE_NUMBER++))
            else
                _report -d "Skipping: ${FILE} (no audio stream found)"
            fi
        done < "${INPUT}"
    fi
    echo "</files>" >> "${FILES_XML_TMP}"
    if [[ "${XML_OUTPUT}" = "y" ]] ; then
        _finish_xml "${FILES_XML_TMP}" > "${OUTPUT_XML}"
    fi
fi
if [[ -f "${DUP_CHECK_TMP}" ]] ; then
    DUP_IMED="$(sort -t '|' -k1 "${DUP_CHECK_TMP}" | awk -F'|' '$1 in first{print first[$1] $0; first[$1]=""; next} {first[$1]=$0 ORS}')"
    if [[ "${DUP_IMED}" != "" ]] ; then
        _report -w "Found some duplicate IMED values..."
        echo "${DUP_IMED}"
    fi
fi
